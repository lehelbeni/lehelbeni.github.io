"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5940],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=o,y=d["".concat(s,".").concat(p)]||d[p]||h[p]||a;return n?r.createElement(y,i(i({ref:t},c),{},{components:n})):r.createElement(y,i({ref:t},c))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5820:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var r=n(7462),o=(n(7294),n(3905));const a={},i="Queries",l={unversionedId:"webdev/GraphQL/Query",id:"webdev/GraphQL/Query",title:"Queries",description:"Fetch data with the useQuery hook",source:"@site/docs/webdev/GraphQL/Query.md",sourceDirName:"webdev/GraphQL",slug:"/webdev/GraphQL/Query",permalink:"/docs/webdev/GraphQL/Query",draft:!1,editUrl:"https://github.com/lehelbeni/lehelbeni.github.io/tree/main/docs/webdev/GraphQL/Query.md",tags:[],version:"current",frontMatter:{},sidebar:"webdevSidebar",previous:{title:"Introduction",permalink:"/docs/webdev/GraphQL/Introduction"}},s={},u=[{value:"Fetch data with the useQuery hook",id:"fetch-data-with-the-usequery-hook",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Executing a query",id:"executing-a-query",level:2},{value:"Caching query results",id:"caching-query-results",level:2},{value:"Updating cached query results",id:"updating-cached-query-results",level:2},{value:"Polling",id:"polling",level:2},{value:"Refetching",id:"refetching",level:2},{value:"Inspecting error states",id:"inspecting-error-states",level:2}],c={toc:u};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"queries"},"Queries"),(0,o.kt)("h2",{id:"fetch-data-with-the-usequery-hook"},"Fetch data with the useQuery hook"),(0,o.kt)("p",null,"This article shows how to fetch GraphQL data in React with the useQuery hook and attach the result to your UI. You'll also learn how Apollo Client simplifies data management code by tracking error and loading states for you."),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"This article assumes you're familiar with building basic GraphQL queries. If you need a refresher, we recommend this guide. You can also build example queries against Apollo's full-stack tutorial server."),(0,o.kt)("p",null,"This article also assumes that you've already set up Apollo Client and have wrapped your React app in an ApolloProvider component. For more information, see the getting started guide."),(0,o.kt)("p",null,"To follow along with the examples below, open up our starter project and sample GraphQL server on CodeSandbox. You can view the completed version of the app here."),(0,o.kt)("h2",{id:"executing-a-query"},"Executing a query"),(0,o.kt)("p",null,"The useQuery React hook is the primary API for executing queries in an Apollo application. To run a query within a React component, call useQuery and pass it a GraphQL query string. When your component renders, useQuery returns an object from Apollo Client that contains loading, error, and data properties you can use to render your UI."),(0,o.kt)("p",null,"Let's look at an example. First, we'll create a GraphQL query named GET_DOGS. Remember to wrap query strings in the gql function to parse them into query documents:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { gql, useQuery } from '@apollo/client';\n\nconst GET_DOGS = gql`\n  query GetDogs {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n")),(0,o.kt)("p",null,"Next, we'll create a component named Dogs. Inside it, we'll pass our GET_DOGS query to the useQuery hook:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function Dogs({ onDogSelected }) {\n  const { loading, error, data } = useQuery(GET_DOGS);\n\n  if (loading) return 'Loading...';\n  if (error) return `Error! ${error.message}`;\n\n  return (\n    <select name='dog' onChange={onDogSelected}>\n      {data.dogs.map((dog) => (\n        <option key={dog.id} value={dog.breed}>\n          {dog.breed}\n        </option>\n      ))}\n    </select>\n  );\n}\n")),(0,o.kt)("p",null,"As our query executes and the values of loading, error, and data change, the Dogs component can intelligently render different UI elements according to the query's state:"),(0,o.kt)("p",null,"As long as loading is true (indicating the query is still in flight), the component presents a Loading... notice.\nWhen loading is false and there is no error, the query has completed. The component renders a dropdown menu that's populated with the list of dog breeds returned by the server.\nWhen the user selects a dog breed from the populated dropdown, the selection is sent to the parent component via the provided onDogSelected function."),(0,o.kt)("p",null,"In the next step, we'll associate the dropdown with a more sophisticated query that uses GraphQL variables."),(0,o.kt)("h2",{id:"caching-query-results"},"Caching query results"),(0,o.kt)("p",null,"Whenever Apollo Client fetches query results from your server, it automatically caches those results locally. This makes later executions of that same query extremely fast."),(0,o.kt)("p",null,"To see this caching in action, let's build a new component called DogPhoto. DogPhoto accepts a prop called breed that reflects the current value of the dropdown menu in our Dogs component:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const GET_DOG_PHOTO = gql`\n  query Dog($breed: String!) {\n    dog(breed: $breed) {\n      id\n      displayImage\n    }\n  }\n`;\n\nfunction DogPhoto({ breed }) {\n  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n  );\n}\n")),(0,o.kt)("p",null,"Notice that we're providing a configuration option (variables) to the useQuery hook this time. The variables option is an object that contains all of the variables we want to pass to our GraphQL query. In this case, we want to pass the currently selected breed from the dropdown."),(0,o.kt)("p",null,"Select bulldog from the dropdown to see its photo appear. Then switch to another breed, and then switch back to bulldog. You'll notice that the bulldog photo loads instantly the second time around. This is the cache at work!"),(0,o.kt)("p",null,"Next, let's learn some techniques for ensuring that our cached data is fresh."),(0,o.kt)("h2",{id:"updating-cached-query-results"},"Updating cached query results"),(0,o.kt)("p",null,"Sometimes, you want to make sure that your query's cached data is up to date with your server's data. Apollo Client supports two strategies for this: polling and refetching."),(0,o.kt)("h2",{id:"polling"},"Polling"),(0,o.kt)("p",null,"Polling provides near-real-time synchronization with your server by executing your query periodically at a specified interval. To enable polling for a query, pass a pollInterval configuration option to the useQuery hook with an interval in milliseconds:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function DogPhoto({ breed }) {\n  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n    pollInterval: 500,\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n  );\n}\n")),(0,o.kt)("p",null,"By setting pollInterval to 500, we fetch the current breed's image from the server every 0.5 seconds. Note that if you set pollInterval to 0, the query does not poll."),(0,o.kt)("p",null,"You can also start and stop polling dynamically with the startPolling and stopPolling functions that are returned by the useQuery hook. When using these functions, set the pollInterval configuration option as a parameter of the startPolling function."),(0,o.kt)("h2",{id:"refetching"},"Refetching"),(0,o.kt)("p",null,"Refetching enables you to refresh query results in response to a particular user action, as opposed to using a fixed interval."),(0,o.kt)("p",null,"Let's add a button to our DogPhoto component that calls our query's refetch function whenever it's clicked."),(0,o.kt)("p",null,"You can optionally provide a new variables object to the refetch function. If you avoid passing a variables object and use only refetch(), the query uses the same variables that it used in its previous execution."),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function DogPhoto({ breed }) {\n  const { loading, error, data, refetch } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <div>\n      <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n      <button onClick={() => refetch({ breed: 'new_dog_breed' })}>\n        Refetch new breed!\n      </button>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,"Click the button and notice that the UI updates with a new dog photo. Refetching is an excellent way to guarantee fresh data, but it introduces some complexity with loading state. In the next section, we'll cover strategies for handling complex loading and error state."),(0,o.kt)("p",null,"Providing new variables to refetch\nYou call refetch with a new set of variables like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"<button\n  onClick={() =>\n    refetch({\n      breed: 'dalmatian', // Always refetches a dalmatian instead of original breed\n    })\n  }\n>\n  Refetch!\n</button>\n")),(0,o.kt)("p",null,"If you provide new values for some of your original query's variables but not all of them, refetch uses each omitted variable's original value."),(0,o.kt)("p",null,"Inspecting loading states\nWe've already seen that the useQuery hook exposes our query's current loading state. This is helpful when a query first loads, but what happens to our loading state when we're refetching or polling?"),(0,o.kt)("p",null,"Let's return to our refetching example from the previous section. If you click the refetch button, you'll see that the component doesn't re-render until the new data arrives. What if we want to indicate to the user that we're refetching the photo?"),(0,o.kt)("p",null,"The useQuery hook's result object provides fine-grained information about the status of the query via the networkStatus property. To take advantage of this information, we set the notifyOnNetworkStatusChange option to true so our query component re-renders while a refetch is in flight:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NetworkStatus } from '@apollo/client';\n\nfunction DogPhoto({ breed }) {\n  const { loading, error, data, refetch, networkStatus } = useQuery(\n    GET_DOG_PHOTO,\n    {\n      variables: { breed },\n      notifyOnNetworkStatusChange: true,\n    }\n  );\n\n  if (networkStatus === NetworkStatus.refetch) return 'Refetching!';\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <div>\n      <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n      <button onClick={() => refetch({ breed: 'new_dog_breed' })}>\n        Refetch!\n      </button>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,"Enabling this option also ensures that the value of loading updates accordingly, even if you don't want to use the more fine-grained information provided by the networkStatus property."),(0,o.kt)("p",null,"The networkStatus property is a NetworkStatus enum that represents different loading states. Refetch is represented by NetworkStatus.refetch, and there are also values for polling and pagination. For a full list of all the possible loading states, check out the source."),(0,o.kt)("p",null,"To view a complete version of the app we just built, check out the CodeSandbox here."),(0,o.kt)("h2",{id:"inspecting-error-states"},"Inspecting error states"),(0,o.kt)("p",null,"You can customize your query error handling by providing the errorPolicy configuration option to the useQuery hook. The default value is none, which tells Apollo Client to treat all GraphQL errors as runtime errors. In this case, Apollo Client discards any query response data returned by the server and sets the error property in the useQuery result object."),(0,o.kt)("p",null,"If you set errorPolicy to all, useQuery does not discard query response data, allowing you to render partial results."),(0,o.kt)("p",null,"For more information, see Handling operation errors."),(0,o.kt)("p",null,"Manual execution with useLazyQuery\nWhen React renders a component that calls useQuery, Apollo Client automatically executes the corresponding query. But what if you want to execute a query in response to a different event, such as a user clicking a button?"),(0,o.kt)("p",null,"The useLazyQuery hook is perfect for executing queries in response to events besides component rendering. Unlike with useQuery, when you call useLazyQuery, it does not immediately execute its associated query. Instead, it returns a query function in its result tuple that you call whenever you're ready to execute the query."),(0,o.kt)("p",null,"Here's an example:"),(0,o.kt)("p",null,"index.js"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React from 'react';\nimport { useLazyQuery } from '@apollo/client';\n\nfunction DelayedQuery() {\n  const [getDog, { loading, error, data }] = useLazyQuery(GET_DOG_PHOTO);\n\n  if (loading) return <p>Loading ...</p>;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <div>\n      {data?.dog && <img src={data.dog.displayImage} />}\n      <button onClick={() => getDog({ variables: { breed: 'bulldog' } })}>\n        Click me!\n      </button>\n    </div>\n  );\n}\n")),(0,o.kt)("p",null,"The first item in useLazyQuery's return tuple is the query function, and the second item is the same result object returned by useQuery."),(0,o.kt)("p",null,"As shown above, you can pass options to the query function just like you pass them to useLazyQuery itself. If you pass a particular option to both, the value you pass to the query function takes precedence. This is a handy way to pass default options to useLazyQuery and then customize those options in the query function."),(0,o.kt)("p",null,"For a full list of supported options, see the API reference."),(0,o.kt)("p",null,"Setting a fetch policy\nBy default, the useQuery hook checks the Apollo Client cache to see if all the data you requested is already available locally. If all data is available locally, useQuery returns that data and doesn't query your GraphQL server. This cache-first policy is Apollo Client's default fetch policy."),(0,o.kt)("p",null,"You can specify a different fetch policy for a given query. To do so, include the fetchPolicy option in your call to useQuery:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const { loading, error, data } = useQuery(GET_DOGS, {\n  fetchPolicy: 'network-only', // Doesn't check cache before making a network request\n});\n")),(0,o.kt)("p",null,"nextFetchPolicy\nYou can also specify a query's nextFetchPolicy. If you do, fetchPolicy is used for the query's first execution, and nextFetchPolicy is used to determine how the query responds to future cache updates:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const { loading, error, data } = useQuery(GET_DOGS, {\n  fetchPolicy: 'network-only', // Used for first execution\n  nextFetchPolicy: 'cache-first', // Used for subsequent executions\n});\n")),(0,o.kt)("p",null,"For example, this is helpful if you want a query to always make an initial network request, but you're comfortable reading from the cache after that."),(0,o.kt)("p",null,"nextFetchPolicy functions\nIf you want to apply a single nextFetchPolicy by default, because you find yourself manually providing nextFetchPolicy for most of your queries, you can configure defaultOptions.watchQuery.nextFetchPolicy when creating your ApolloClient instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new ApolloClient({\n  link,\n  client,\n  defaultOptions: {\n    watchQuery: {\n      nextFetchPolicy: 'cache-only',\n    },\n  },\n});\n")),(0,o.kt)("p",null,"This configuration applies to all client.watchQuery calls and useQuery calls that do not otherwise configure nextFetchPolicy."),(0,o.kt)("p",null,"If you want more control over how nextFetchPolicy behaves, you can provide a function instead of a WatchQueryFetchPolicy string:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new ApolloClient({\n  link,\n  client,\n  defaultOptions: {\n    watchQuery: {\n      nextFetchPolicy(currentFetchPolicy) {\n        if (\n          currentFetchPolicy === 'network-only' ||\n          currentFetchPolicy === 'cache-and-network'\n        ) {\n          // Demote the network policies (except \"no-cache\") to \"cache-first\"\n          // after the first request.\n          return 'cache-first';\n        }\n        // Leave all other fetch policies unchanged.\n        return currentFetchPolicy;\n      },\n    },\n  },\n});\n")),(0,o.kt)("p",null,"This nextFetchPolicy function will be called after each request, and uses the currentFetchPolicy parameter to decide how to modify the fetch policy."),(0,o.kt)("p",null,"In addition to being called after each request, your nextFetchPolicy function will also be called when variables change, which by default resets the fetchPolicy to its initial value, which is often important to trigger a fresh network request for queries that started out with cache-and-network or network-only fetch policies."),(0,o.kt)("p",null,"To intercept and handle the variables-changed case yourself, you can use the NextFetchPolicyContext object passed as the second argument to your nextFetchPolicy function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new ApolloClient({\n  link,\n  client,\n  defaultOptions: {\n    watchQuery: {\n      nextFetchPolicy(\n        currentFetchPolicy,\n        {\n          // Either \"after-fetch\" or \"variables-changed\", indicating why the\n          // nextFetchPolicy function was invoked.\n          reason,\n          // The rest of the options (currentFetchPolicy === options.fetchPolicy).\n          options,\n          // The original value of options.fetchPolicy, before nextFetchPolicy was\n          // applied for the first time.\n          initialPolicy,\n          // The ObservableQuery associated with this client.watchQuery call.\n          observable,\n        }\n      ) {\n        // When variables change, the default behavior is to reset\n        // options.fetchPolicy to context.initialPolicy. If you omit this logic,\n        // your nextFetchPolicy function can override this default behavior to\n        // prevent options.fetchPolicy from changing in this case.\n        if (reason === 'variables-changed') {\n          return initialPolicy;\n        }\n\n        if (\n          currentFetchPolicy === 'network-only' ||\n          currentFetchPolicy === 'cache-and-network'\n        ) {\n          // Demote the network policies (except \"no-cache\") to \"cache-first\"\n          // after the first request.\n          return 'cache-first';\n        }\n\n        // Leave all other fetch policies unchanged.\n        return currentFetchPolicy;\n      },\n    },\n  },\n});\n")),(0,o.kt)("p",null,"In order to debug these nextFetchPolicy transitions, it can be useful to add console.log or debugger statements to the function body, to see when and why the function is called."),(0,o.kt)("p",null,"Supported fetch policies\nNAME\tDESCRIPTION\ncache-first\nApollo Client first executes the query against the cache. If all requested data is present in the cache, that data is returned. Otherwise, Apollo Client executes the query against your GraphQL server and returns that data after caching it."),(0,o.kt)("p",null,"Prioritizes minimizing the number of network requests sent by your application."),(0,o.kt)("p",null,"This is the default fetch policy."),(0,o.kt)("p",null,"cache-only\nApollo Client executes the query only against the cache. It never queries your server in this case."),(0,o.kt)("p",null,"A cache-only query throws an error if the cache does not contain data for all requested fields."),(0,o.kt)("p",null,"cache-and-network\nApollo Client executes the full query against both the cache and your GraphQL server. The query automatically updates if the result of the server-side query modifies cached fields."),(0,o.kt)("p",null,"Provides a fast response while also helping to keep cached data consistent with server data."),(0,o.kt)("p",null,"network-only\nApollo Client executes the full query against your GraphQL server, without first checking the cache. The query's result is stored in the cache."),(0,o.kt)("p",null,"Prioritizes consistency with server data, but can't provide a near-instantaneous response when cached data is available."),(0,o.kt)("p",null,"no-cache\nSimilar to network-only, except the query's result is not stored in the cache."),(0,o.kt)("p",null,"standby\nUses the same logic as cache-first, except this query does not automatically update when underlying field values change. You can still manually update this query with refetch and updateQueries."),(0,o.kt)("p",null,"useQuery API\nSupported options and result fields for the useQuery hook are listed below."),(0,o.kt)("p",null,"Most calls to useQuery can omit the majority of these options, but it's useful to know they exist. To learn about the useQuery hook API in more detail with usage examples, see the API reference."))}h.isMDXComponent=!0}}]);