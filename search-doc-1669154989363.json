[{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"Introduction","keywords":""},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"hey","type":0,"sectionRef":"#","url":"/docs/docs/intro","content":"hey","keywords":""},{"title":"E69: Elon Musk on Twitter's bot problem, SpaceX's grand plan, Tesla stories, Giga Texas & more","type":0,"sectionRef":"#","url":"/docs/mindcast/All In Podcast/E69: Elon Musk on Twitters bot problem, SpaceXs grand plan, Tesla stories, Giga Texas & more","content":"","keywords":""},{"title":"Table of Content​","type":1,"pageTitle":"E69: Elon Musk on Twitter's bot problem, SpaceX's grand plan, Tesla stories, Giga Texas & more","url":"/docs/mindcast/All In Podcast/E69: Elon Musk on Twitters bot problem, SpaceXs grand plan, Tesla stories, Giga Texas & more#table-of-content","content":"0:00 Bestie Guestie Elon Musk joins the besties via Zoom at the All-In Summit!0:43 Benchmarking Twitter's bot problem, thoughts on slights from the Biden Administration13:26 Breaking down Tesla's 6+ businesses, comparing them to a traditional car company21:42 Concerns around the Twitter deal, crypto payments on Twitter30:19 Building vs. acquiring, early Tesla stories39:52 SpaceX's grand vision and business model, nuclear fusion vs. solar56:37 Moving from CA to TX, fixing California, macroeconomic takes1:10:20 American exceptionalism, a new immigration strategy  Legacy The legacy supply chain comes with the the inherent constraint. "},{"title":"intro","type":0,"sectionRef":"#","url":"/docs/neurosurgery/intro","content":"intro","keywords":""},{"title":"Mindcast","type":0,"sectionRef":"#","url":"/docs/mindcast/intro","content":"Mindcast","keywords":""},{"title":"The All In Podcast","type":0,"sectionRef":"#","url":"/docs/mindcast/All In Podcast/intro","content":"The All In Podcast","keywords":""},{"title":"Documentation Init","type":0,"sectionRef":"#","url":"/docs/docs/Documentation/main","content":"Documentation Init","keywords":""},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"338 Chamath Palihapitiya: Money, Success, Startups, Energy, Poker & Happiness | Lex Fridman Podcast","type":0,"sectionRef":"#","url":"/docs/mindcast/Lex Friedman/338 Lex Friedman","content":"","keywords":""},{"title":"Episode outline​","type":1,"pageTitle":"338 Chamath Palihapitiya: Money, Success, Startups, Energy, Poker & Happiness | Lex Fridman Podcast","url":"/docs/mindcast/Lex Friedman/338 Lex Friedman#episode-outline","content":"1:05 - Childhood and forgiveness14:49 - Money and happiness21:40 - Poker25:07 - Mistakes35:58 - Early jobs37:35 - Facebook55:21 - Energy1:03:01 - Cloud computation1:07:17 - Fixing social media1:17:08 - Trump's Twitter ban1:22:13 - Kanye West1:33:25 - All-In Podcast1:42:41 - Nuclear war1:54:17 - Startups2:02:48 - Work-life balance2:13:57 - Teamwork2:25:18 - Energy transition2:35:51 - Silicon Valley culture2:39:10 - Activism culture2:43:32 - Advice for young people2:50:07 - Meaning of life "},{"title":"Mistakes in geting started a company​","type":1,"pageTitle":"338 Chamath Palihapitiya: Money, Success, Startups, Energy, Poker & Happiness | Lex Fridman Podcast","url":"/docs/mindcast/Lex Friedman/338 Lex Friedman#mistakes-in-geting-started-a-company","content":"starting a business is realy hard; "},{"title":"Mistakes about people in a startup​","type":1,"pageTitle":"338 Chamath Palihapitiya: Money, Success, Startups, Energy, Poker & Happiness | Lex Fridman Podcast","url":"/docs/mindcast/Lex Friedman/338 Lex Friedman#mistakes-about-people-in-a-startup","content":"There are only three types of mistakes: hire somebody that is realy avereage, but a realy good person; - (important and useful people, they are like carlidge) &lt;50% of Ntotal of people in companyhire somebody that is different that it presented; not good moraly, but very performant; - (keeping around) The tree faliure cases in hireing. These are the main cases that are fatal for a acompany. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/webdev/GraphQL/Introduction","content":"Introduction","keywords":""},{"title":"Creating a development server","type":0,"sectionRef":"#","url":"/docs/webdev/DevOps/creating-development-server","content":"","keywords":""},{"title":"Available Technologies​","type":1,"pageTitle":"Creating a development server","url":"/docs/webdev/DevOps/creating-development-server#available-technologies","content":"The main tools that you can use to create automatic deployment on your website are Jenkins Docker Container "},{"title":"The building of the project​","type":1,"pageTitle":"Creating a development server","url":"/docs/webdev/DevOps/creating-development-server#the-building-of-the-project","content":"The main problem at the time is serving the static website directly from the backend sever and working together. "},{"title":"Configuring .env file​","type":1,"pageTitle":"Creating a development server","url":"/docs/webdev/DevOps/creating-development-server#configuring-env-file","content":"The first step you need to take is to configure the .env file both in client and server configuration. so the client config will look like this  { //API REACT_APP_API: 'http://localhost:4000', // HOST HOST_API_KEY: 'https://api-dev-minimal-v4.vercel.app', // MAPBOX MAPBOX_API: '', // FIREBASE FIREBASE_API_KEY: '', FIREBASE_AUTH_DOMAIN: '', FIREBASE_PROJECT_ID: '', FIREBASE_STORAGE_BUCKET: '', FIREBASE_MESSAGING_SENDER_ID: '', FIREBASE_APPID: '', FIREBASE_MEASUREMENT_ID: '', // AWS COGNITO AWS_COGNITO_USER_POOL_ID: '', AWS_COGNITO_CLIENT_ID: '', // AUTH0 AUTH0_DOMAIN: '', AUTH0_CLIENT_ID: '', }  "},{"title":"The​","type":1,"pageTitle":"Creating a development server","url":"/docs/webdev/DevOps/creating-development-server#the","content":""},{"title":"How to deploy your websites","type":0,"sectionRef":"#","url":"/docs/webdev/DevOps/deploying-your-site","content":"How to deploy your websites","keywords":""},{"title":"NGNIX","type":0,"sectionRef":"#","url":"/docs/webdev/DevOps/NGINX","content":"","keywords":""},{"title":"Serving a static webpage​","type":1,"pageTitle":"NGNIX","url":"/docs/webdev/DevOps/NGINX#serving-a-static-webpage","content":"When you have the server and the client page build, you have to "},{"title":"Create Docker Image","type":0,"sectionRef":"#","url":"/docs/webdev/Docker/DockerConfig","content":"","keywords":""},{"title":"Production server​","type":1,"pageTitle":"Create Docker Image","url":"/docs/webdev/Docker/DockerConfig#production-server","content":"docker-compose -f docker-compose.yml -f docker-compose-prod.yml up -d --build  "},{"title":"The essentials","type":0,"sectionRef":"#","url":"/docs/webdev/intro","content":"","keywords":""},{"title":"Short table of content​","type":1,"pageTitle":"The essentials","url":"/docs/webdev/intro#short-table-of-content","content":"Docusaurus documentationDevOps aka. all you need to set up a litle React NodeJs webserver "},{"title":"Docusaurus","type":0,"sectionRef":"#","url":"/docs/webdev/docusaurus","content":"","keywords":""},{"title":"Creating a docusaurus docuemntation​","type":1,"pageTitle":"Docusaurus","url":"/docs/webdev/docusaurus#creating-a-docusaurus-docuemntation","content":""},{"title":"Updating the documentation​","type":1,"pageTitle":"Docusaurus","url":"/docs/webdev/docusaurus#updating-the-documentation","content":"git add . git commit -m &quot;Update&quot; git push origin main GIT_USER=lehelbeni yarn deploy  ... and then start here of course ... "},{"title":"Publish Docusaurus to GitHub Pages​","type":1,"pageTitle":"Docusaurus","url":"/docs/webdev/docusaurus#publish-docusaurus-to-github-pages","content":"Create new Git Repository and git push origin main the new git repo Edith docusaurus.config.js  title: &quot;lehelbeni.md&quot;, tagline: &quot;Dinosaurs are cool&quot;, url: &quot;https://lehelbeni.github.io&quot;, baseUrl: &quot;/&quot;, onBrokenLinks: &quot;throw&quot;, onBrokenMarkdownLinks: &quot;warn&quot;, favicon: &quot;img/favicon.ico&quot;, // GitHub pages deployment config. // If you aren't using GitHub pages, you don't need these. organizationName: &quot;lehelbeni&quot;, // Usually your GitHub org/user name. projectName: &quot;lehelbeni.github.io&quot;, // Usually your repo name. deploymentBranch: &quot;gh-pages&quot;,  "},{"title":"Building and deploying to github pages​","type":1,"pageTitle":"Docusaurus","url":"/docs/webdev/docusaurus#building-and-deploying-to-github-pages","content":"First ajust the settings in the project directory Settings-&gt;Pages-&gt; deploy from branch -&gt; gh-pages "},{"title":"Adding Searh to your docusaurus site​","type":1,"pageTitle":"Docusaurus","url":"/docs/webdev/docusaurus#adding-searh-to-your-docusaurus-site","content":"Install this package npm i docusaurus-lunr-search --save  Then run npm install to update, build, and link the packages npm install  Add the docusaurus-lunr-search plugin to your docusaurus.config.js module.exports = { // ... plugins: [require.resolve('docusaurus-lunr-search')], }  Then run docusaurus swizzle npm run swizzle docusaurus-lunr-search SearchBar -- --eject --danger  Then build your Docusaurus project npm run build  Serve your application npx http-server ./build  "},{"title":"GitHub Cheat sheet","type":0,"sectionRef":"#","url":"/docs/webdev/DevOps/git","content":"","keywords":""},{"title":"Initialising a new .git directory​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#initialising-a-new-git-directory","content":""},{"title":"…or create a new repository on the command line​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#or-create-a-new-repository-on-the-command-line","content":"echo &quot;# Title Page&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/lehelbeni/&lt;reponame.git&gt; git push -u origin main  "},{"title":"…or create a new repository on the command line​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#or-create-a-new-repository-on-the-command-line-1","content":"git remote add origin https://github.com/lehelbeni/new.git git branch -M main git push -u origin main  "},{"title":"Share and Update​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#share-and-update","content":"# add a git URL as an alias git remote add [alias] [url] # fetch down all the branches from that Git remote git fetch [alias] # merge a remote branch into your current branch to bring it up to date git merge [alias]/[branch] # Transmit local branch commits to the remote repository branch git push [alias] [branch] # fetch and merge any commits from the tracking remote branch git pull  "},{"title":"Setup and Init​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#setup-and-init","content":"Configuring information, initializing and cloning repositories git init git clone [url]  "},{"title":"Stage and Snapshot​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#stage-and-snapshot","content":"Working with snapshots and the Git staging area. # show modified files in working directory, staged for your next commit git status # add a file as it looks now to your next commit (stage) git add [file] # unstage a file while retaining the changes in working directory git reset [file] # diff of what is changed but not staged git diff # commit your staged content as a new commit snapshot git commit -m &quot;[descriptive message]&quot;  "},{"title":"Branch and Merge​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#branch-and-merge","content":"Isolating work in branches, changing context, and integrating changes # list your branches. a * will appear next to the currently active branch git branch # create a new branch at the current commit git branch [branch-name] # switch to another branch and check it out into your working directory git checkout # merge the specified branch’s history into the current one git merge [branch] # show all commits in the current branch’s history git log  "},{"title":"Setup​","type":1,"pageTitle":"GitHub Cheat sheet","url":"/docs/webdev/DevOps/git#setup","content":"Configuring user information used across all local repositories # set a name that is identifiable for credit when review version history git config --global user.name “[firstname lastname]” # set an email address that will be associated with each history marker git config --global user.email “[valid-email]” # set automatic command line coloring for Git for easy reviewing git config --global color.ui auto  "},{"title":"Queries","type":0,"sectionRef":"#","url":"/docs/webdev/GraphQL/Query","content":"","keywords":""},{"title":"Fetch data with the useQuery hook​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#fetch-data-with-the-usequery-hook","content":"This article shows how to fetch GraphQL data in React with the useQuery hook and attach the result to your UI. You'll also learn how Apollo Client simplifies data management code by tracking error and loading states for you. "},{"title":"Prerequisites​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#prerequisites","content":"This article assumes you're familiar with building basic GraphQL queries. If you need a refresher, we recommend this guide. You can also build example queries against Apollo's full-stack tutorial server. This article also assumes that you've already set up Apollo Client and have wrapped your React app in an ApolloProvider component. For more information, see the getting started guide. To follow along with the examples below, open up our starter project and sample GraphQL server on CodeSandbox. You can view the completed version of the app here. "},{"title":"Executing a query​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#executing-a-query","content":"The useQuery React hook is the primary API for executing queries in an Apollo application. To run a query within a React component, call useQuery and pass it a GraphQL query string. When your component renders, useQuery returns an object from Apollo Client that contains loading, error, and data properties you can use to render your UI. Let's look at an example. First, we'll create a GraphQL query named GET_DOGS. Remember to wrap query strings in the gql function to parse them into query documents: index.js import { gql, useQuery } from '@apollo/client'; const GET_DOGS = gql` query GetDogs { dogs { id breed } } `;  Next, we'll create a component named Dogs. Inside it, we'll pass our GET_DOGS query to the useQuery hook: index.js function Dogs({ onDogSelected }) { const { loading, error, data } = useQuery(GET_DOGS); if (loading) return 'Loading...'; if (error) return `Error! ${error.message}`; return ( &lt;select name='dog' onChange={onDogSelected}&gt; {data.dogs.map((dog) =&gt; ( &lt;option key={dog.id} value={dog.breed}&gt; {dog.breed} &lt;/option&gt; ))} &lt;/select&gt; ); }  As our query executes and the values of loading, error, and data change, the Dogs component can intelligently render different UI elements according to the query's state: As long as loading is true (indicating the query is still in flight), the component presents a Loading... notice. When loading is false and there is no error, the query has completed. The component renders a dropdown menu that's populated with the list of dog breeds returned by the server. When the user selects a dog breed from the populated dropdown, the selection is sent to the parent component via the provided onDogSelected function. In the next step, we'll associate the dropdown with a more sophisticated query that uses GraphQL variables. "},{"title":"Caching query results​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#caching-query-results","content":"Whenever Apollo Client fetches query results from your server, it automatically caches those results locally. This makes later executions of that same query extremely fast. To see this caching in action, let's build a new component called DogPhoto. DogPhoto accepts a prop called breed that reflects the current value of the dropdown menu in our Dogs component: index.js const GET_DOG_PHOTO = gql` query Dog($breed: String!) { dog(breed: $breed) { id displayImage } } `; function DogPhoto({ breed }) { const { loading, error, data } = useQuery(GET_DOG_PHOTO, { variables: { breed }, }); if (loading) return null; if (error) return `Error! ${error}`; return ( &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; ); }  Notice that we're providing a configuration option (variables) to the useQuery hook this time. The variables option is an object that contains all of the variables we want to pass to our GraphQL query. In this case, we want to pass the currently selected breed from the dropdown. Select bulldog from the dropdown to see its photo appear. Then switch to another breed, and then switch back to bulldog. You'll notice that the bulldog photo loads instantly the second time around. This is the cache at work! Next, let's learn some techniques for ensuring that our cached data is fresh. "},{"title":"Updating cached query results​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#updating-cached-query-results","content":"Sometimes, you want to make sure that your query's cached data is up to date with your server's data. Apollo Client supports two strategies for this: polling and refetching. "},{"title":"Polling​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#polling","content":"Polling provides near-real-time synchronization with your server by executing your query periodically at a specified interval. To enable polling for a query, pass a pollInterval configuration option to the useQuery hook with an interval in milliseconds: index.js function DogPhoto({ breed }) { const { loading, error, data } = useQuery(GET_DOG_PHOTO, { variables: { breed }, pollInterval: 500, }); if (loading) return null; if (error) return `Error! ${error}`; return ( &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; ); }  By setting pollInterval to 500, we fetch the current breed's image from the server every 0.5 seconds. Note that if you set pollInterval to 0, the query does not poll. You can also start and stop polling dynamically with the startPolling and stopPolling functions that are returned by the useQuery hook. When using these functions, set the pollInterval configuration option as a parameter of the startPolling function. "},{"title":"Refetching​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#refetching","content":"Refetching enables you to refresh query results in response to a particular user action, as opposed to using a fixed interval. Let's add a button to our DogPhoto component that calls our query's refetch function whenever it's clicked. You can optionally provide a new variables object to the refetch function. If you avoid passing a variables object and use only refetch(), the query uses the same variables that it used in its previous execution. index.js function DogPhoto({ breed }) { const { loading, error, data, refetch } = useQuery(GET_DOG_PHOTO, { variables: { breed }, }); if (loading) return null; if (error) return `Error! ${error}`; return ( &lt;div&gt; &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; &lt;button onClick={() =&gt; refetch({ breed: 'new_dog_breed' })}&gt; Refetch new breed! &lt;/button&gt; &lt;/div&gt; ); }  Click the button and notice that the UI updates with a new dog photo. Refetching is an excellent way to guarantee fresh data, but it introduces some complexity with loading state. In the next section, we'll cover strategies for handling complex loading and error state. Providing new variables to refetch You call refetch with a new set of variables like so: &lt;button onClick={() =&gt; refetch({ breed: 'dalmatian', // Always refetches a dalmatian instead of original breed }) } &gt; Refetch! &lt;/button&gt;  If you provide new values for some of your original query's variables but not all of them, refetch uses each omitted variable's original value. Inspecting loading states We've already seen that the useQuery hook exposes our query's current loading state. This is helpful when a query first loads, but what happens to our loading state when we're refetching or polling? Let's return to our refetching example from the previous section. If you click the refetch button, you'll see that the component doesn't re-render until the new data arrives. What if we want to indicate to the user that we're refetching the photo? The useQuery hook's result object provides fine-grained information about the status of the query via the networkStatus property. To take advantage of this information, we set the notifyOnNetworkStatusChange option to true so our query component re-renders while a refetch is in flight: index.js import { NetworkStatus } from '@apollo/client'; function DogPhoto({ breed }) { const { loading, error, data, refetch, networkStatus } = useQuery( GET_DOG_PHOTO, { variables: { breed }, notifyOnNetworkStatusChange: true, } ); if (networkStatus === NetworkStatus.refetch) return 'Refetching!'; if (loading) return null; if (error) return `Error! ${error}`; return ( &lt;div&gt; &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; &lt;button onClick={() =&gt; refetch({ breed: 'new_dog_breed' })}&gt; Refetch! &lt;/button&gt; &lt;/div&gt; ); }  Enabling this option also ensures that the value of loading updates accordingly, even if you don't want to use the more fine-grained information provided by the networkStatus property. The networkStatus property is a NetworkStatus enum that represents different loading states. Refetch is represented by NetworkStatus.refetch, and there are also values for polling and pagination. For a full list of all the possible loading states, check out the source. To view a complete version of the app we just built, check out the CodeSandbox here. "},{"title":"Inspecting error states​","type":1,"pageTitle":"Queries","url":"/docs/webdev/GraphQL/Query#inspecting-error-states","content":"You can customize your query error handling by providing the errorPolicy configuration option to the useQuery hook. The default value is none, which tells Apollo Client to treat all GraphQL errors as runtime errors. In this case, Apollo Client discards any query response data returned by the server and sets the error property in the useQuery result object. If you set errorPolicy to all, useQuery does not discard query response data, allowing you to render partial results. For more information, see Handling operation errors. Manual execution with useLazyQuery When React renders a component that calls useQuery, Apollo Client automatically executes the corresponding query. But what if you want to execute a query in response to a different event, such as a user clicking a button? The useLazyQuery hook is perfect for executing queries in response to events besides component rendering. Unlike with useQuery, when you call useLazyQuery, it does not immediately execute its associated query. Instead, it returns a query function in its result tuple that you call whenever you're ready to execute the query. Here's an example: index.js import React from 'react'; import { useLazyQuery } from '@apollo/client'; function DelayedQuery() { const [getDog, { loading, error, data }] = useLazyQuery(GET_DOG_PHOTO); if (loading) return &lt;p&gt;Loading ...&lt;/p&gt;; if (error) return `Error! ${error}`; return ( &lt;div&gt; {data?.dog &amp;&amp; &lt;img src={data.dog.displayImage} /&gt;} &lt;button onClick={() =&gt; getDog({ variables: { breed: 'bulldog' } })}&gt; Click me! &lt;/button&gt; &lt;/div&gt; ); }  The first item in useLazyQuery's return tuple is the query function, and the second item is the same result object returned by useQuery. As shown above, you can pass options to the query function just like you pass them to useLazyQuery itself. If you pass a particular option to both, the value you pass to the query function takes precedence. This is a handy way to pass default options to useLazyQuery and then customize those options in the query function. For a full list of supported options, see the API reference. Setting a fetch policy By default, the useQuery hook checks the Apollo Client cache to see if all the data you requested is already available locally. If all data is available locally, useQuery returns that data and doesn't query your GraphQL server. This cache-first policy is Apollo Client's default fetch policy. You can specify a different fetch policy for a given query. To do so, include the fetchPolicy option in your call to useQuery: const { loading, error, data } = useQuery(GET_DOGS, { fetchPolicy: 'network-only', // Doesn't check cache before making a network request });  nextFetchPolicy You can also specify a query's nextFetchPolicy. If you do, fetchPolicy is used for the query's first execution, and nextFetchPolicy is used to determine how the query responds to future cache updates: const { loading, error, data } = useQuery(GET_DOGS, { fetchPolicy: 'network-only', // Used for first execution nextFetchPolicy: 'cache-first', // Used for subsequent executions });  For example, this is helpful if you want a query to always make an initial network request, but you're comfortable reading from the cache after that. nextFetchPolicy functions If you want to apply a single nextFetchPolicy by default, because you find yourself manually providing nextFetchPolicy for most of your queries, you can configure defaultOptions.watchQuery.nextFetchPolicy when creating your ApolloClient instance: new ApolloClient({ link, client, defaultOptions: { watchQuery: { nextFetchPolicy: 'cache-only', }, }, });  This configuration applies to all client.watchQuery calls and useQuery calls that do not otherwise configure nextFetchPolicy. If you want more control over how nextFetchPolicy behaves, you can provide a function instead of a WatchQueryFetchPolicy string: new ApolloClient({ link, client, defaultOptions: { watchQuery: { nextFetchPolicy(currentFetchPolicy) { if ( currentFetchPolicy === 'network-only' || currentFetchPolicy === 'cache-and-network' ) { // Demote the network policies (except &quot;no-cache&quot;) to &quot;cache-first&quot; // after the first request. return 'cache-first'; } // Leave all other fetch policies unchanged. return currentFetchPolicy; }, }, }, });  This nextFetchPolicy function will be called after each request, and uses the currentFetchPolicy parameter to decide how to modify the fetch policy. In addition to being called after each request, your nextFetchPolicy function will also be called when variables change, which by default resets the fetchPolicy to its initial value, which is often important to trigger a fresh network request for queries that started out with cache-and-network or network-only fetch policies. To intercept and handle the variables-changed case yourself, you can use the NextFetchPolicyContext object passed as the second argument to your nextFetchPolicy function: new ApolloClient({ link, client, defaultOptions: { watchQuery: { nextFetchPolicy( currentFetchPolicy, { // Either &quot;after-fetch&quot; or &quot;variables-changed&quot;, indicating why the // nextFetchPolicy function was invoked. reason, // The rest of the options (currentFetchPolicy === options.fetchPolicy). options, // The original value of options.fetchPolicy, before nextFetchPolicy was // applied for the first time. initialPolicy, // The ObservableQuery associated with this client.watchQuery call. observable, } ) { // When variables change, the default behavior is to reset // options.fetchPolicy to context.initialPolicy. If you omit this logic, // your nextFetchPolicy function can override this default behavior to // prevent options.fetchPolicy from changing in this case. if (reason === 'variables-changed') { return initialPolicy; } if ( currentFetchPolicy === 'network-only' || currentFetchPolicy === 'cache-and-network' ) { // Demote the network policies (except &quot;no-cache&quot;) to &quot;cache-first&quot; // after the first request. return 'cache-first'; } // Leave all other fetch policies unchanged. return currentFetchPolicy; }, }, }, });  In order to debug these nextFetchPolicy transitions, it can be useful to add console.log or debugger statements to the function body, to see when and why the function is called. Supported fetch policies NAME DESCRIPTION cache-first Apollo Client first executes the query against the cache. If all requested data is present in the cache, that data is returned. Otherwise, Apollo Client executes the query against your GraphQL server and returns that data after caching it. Prioritizes minimizing the number of network requests sent by your application. This is the default fetch policy. cache-only Apollo Client executes the query only against the cache. It never queries your server in this case. A cache-only query throws an error if the cache does not contain data for all requested fields. cache-and-network Apollo Client executes the full query against both the cache and your GraphQL server. The query automatically updates if the result of the server-side query modifies cached fields. Provides a fast response while also helping to keep cached data consistent with server data. network-only Apollo Client executes the full query against your GraphQL server, without first checking the cache. The query's result is stored in the cache. Prioritizes consistency with server data, but can't provide a near-instantaneous response when cached data is available. no-cache Similar to network-only, except the query's result is not stored in the cache. standby Uses the same logic as cache-first, except this query does not automatically update when underlying field values change. You can still manually update this query with refetch and updateQueries. useQuery API Supported options and result fields for the useQuery hook are listed below. Most calls to useQuery can omit the majority of these options, but it's useful to know they exist. To learn about the useQuery hook API in more detail with usage examples, see the API reference. "}]